Catch a lot of errors: alias comp='make CXXFLAGS="-std=c++17 -Wall -Wextra -O3 -fsanitize=address,undefined"'
Compile like in OI: alias comp_oi='make CXXFLAGS="-O3 -static -std=c++17"'

***
CZYTAJ TREŚCI
***

STL: https://www.cplusplus.com/reference

TESTOWANIE:
- MAŁE WARTOŚCI - (3 - 20 elementów w tablicy, wierzchołków grafu, żeby można było sprawdzić brutem)
- DRZEWA - linie, gwiazdy
- EDGE CASES
- #warning jakiś tekst (w razie gdyby trzeba było o czymś pamiętać)

RÓZNE:
- Zrobić dany proces od tyłu
- Czy jakaś właściwość jest niezmienna podczas operacji (np. suma całej tablicy)
- LONG LONG INTY
- Rozdzielanie zmiennych
- Dużo podstawowych rzeczy jest na CSES
- przestawianie zmiennych w równaniu
- tablicowanie (n <= 10^6)
- BIN SEARCH po odpowiedzi
- *****INDEX OUT OF BOUNDS

upper_bound albo lower_bound - a.begin() zwraca rozmiar, jeżeli nie znalazło niczego (MOŻE ZWRÓCIĆ ŚMIECI)
ITERATORY: np. vector <int> :: iterator

MATMA:
- Parzystość
- Potęgi 2
- Przedstawić liczbe jako dzielniki pierwsze
- 2 to jedyna parzysta pierwsza
- Sito 
- x = a1^p1 * a2^p2 * ... * an^pn, wtedy ilość dzielników x = (p1 + 1) * (p1 + 1) *...* (pn + 1)

KOMBINATORYKA:
- Ilość nieporządków (derangements) D(0) = 1, D(1) = 0, D(n) = (n - 1)(D(n - 1) + D(n - 2))
- Stars and bars
- Inclusion-exclusion

GRAFY:
- Silnie spójne
- Dwudzielność
- Graf stanów (+ np. z maskami)
- Mosty, punkty artykulacji, bridge tree ("Terroryści" z kółka)
- Dijkstra

DRZEWA:
- LCA
- DP
- dist(a, b) = depth[a] + depth[b] - 2 * depth[LCA(a, b)]

BITOWE:
- a ^ 0 = a
- a ^ a = 0
- a & b <= min(a, b)
- n-ty bit jest ważniejszy niż wszystkie wcześniejsze razem

GRY:
- niech p - pozycja, p_i - pozycje, do których możemy przejść z p
- f(p) = mex(p_i), 0 jeżeli p jest przegrywająca, dodatnia wpp
- wartość f(p1, p2, ..., pn) (tzn. np. nim na wielu stosach) = xor f(p_i)

GEOMETRIA:
- sortowanie punktów
- wzór Picka
